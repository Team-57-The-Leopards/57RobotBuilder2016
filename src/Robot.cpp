// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Robot.h"
#include "Commands\LiftMan.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<Chassis> Robot::chassis;
std::shared_ptr<IntakeArm> Robot::intakeArm;
std::shared_ptr<Rollers> Robot::rollers;
std::shared_ptr<Lift> Robot::lift;
std::shared_ptr<LiftAngle> Robot::liftAngle;
std::unique_ptr<OI> Robot::oi;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

bool Robot::oldCameraSel = false;
bool Robot::CameraSel = false;
bool Robot::liftMode = false;

void Robot::RobotInit() {
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    chassis.reset(new Chassis());
    intakeArm.reset(new IntakeArm());
    rollers.reset(new Rollers());
    lift.reset(new Lift());
    liftAngle.reset(new LiftAngle());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi.reset(new OI());

	// instantiate the command used for the autonomous period
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	autonomousCommand.reset(new AutonomousCommand());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

	frame = imaqCreateImage(IMAQ_IMAGE_RGB, 0);
	//the camera name (ex "cam0") can be found through the roborio web interface
	imaqError = IMAQdxOpenCamera("cam0", IMAQdxCameraControlModeController, &session);
	if(imaqError != IMAQdxErrorSuccess) {
		DriverStation::ReportError("IMAQdxOpenCamera error: " + std::to_string((long)imaqError) + "\n");
	}
	imaqError = IMAQdxConfigureGrab(session);
	if(imaqError != IMAQdxErrorSuccess) {
		DriverStation::ReportError("IMAQdxConfigureGrab error: " + std::to_string((long)imaqError) + "\n");
	}
//	imaqError = IMAQdxOpenCamera("cam2", IMAQdxCameraControlModeController, &session2);
//	if(imaqError != IMAQdxErrorSuccess) {
//		DriverStation::ReportError("IMAQdxOpenCamera error: " + std::to_string((long)imaqError) + "\n");
//	}
//	imaqError = IMAQdxConfigureGrab(session2);
//	if(imaqError != IMAQdxErrorSuccess) {
//		DriverStation::ReportError("IMAQdxConfigureGrab error: " + std::to_string((long)imaqError) + "\n");
//	}
	Robot::CameraSel = false;
	Robot::oldCameraSel = false;
	Robot::liftMode = false;
  }

/**
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit(){
	Robot::intakeArm->Run(0);
	Robot::liftMode = false;
	Command* liftStop = new LiftMan(0);
	liftStop->Start();
	IMAQdxStopAcquisition(session);
//	IMAQdxStopAcquisition(session2);
}

void Robot::DisabledPeriodic() {
	Scheduler::GetInstance()->Run();
}

void Robot::AutonomousInit() {
	if (autonomousCommand.get() != nullptr)
		autonomousCommand->Start();
}

void Robot::AutonomousPeriodic() {
	Scheduler::GetInstance()->Run();
}

void Robot::TeleopInit() {
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to
	// continue until interrupted by another command, remove
	// these lines or comment it out.
	if (autonomousCommand.get() != nullptr)
		autonomousCommand->Cancel();
	Robot::intakeArm->Run(0);
	IMAQdxStartAcquisition(session);
//	IMAQdxStartAcquisition(session2);
}

void Robot::TeleopPeriodic() {
	Scheduler::GetInstance()->Run();
	SmartDashboard::PutNumber("Arm Pos:",Robot::intakeArm->GetPos());
	SmartDashboard::PutNumber("POV:",oi->getDriveStick()->GetPOV(0));
	SmartDashboard::PutBoolean("old:",oldCameraSel);
	SmartDashboard::PutBoolean("sel:",CameraSel);
	double time = 0;
	if (oldCameraSel != CameraSel)
	{
		time = Timer::GetFPGATimestamp();
		IMAQdxStopAcquisition(session);
		IMAQdxUnconfigureAcquisition(session);
		IMAQdxCloseCamera(session);
		if (CameraSel)
			imaqError = IMAQdxOpenCamera("cam2", IMAQdxCameraControlModeController, &session);
		else
			imaqError = IMAQdxOpenCamera("cam0", IMAQdxCameraControlModeController, &session);
		if(imaqError != IMAQdxErrorSuccess) {
			DriverStation::ReportError("IMAQdxOpenCamera error: " + std::to_string((long)imaqError) + "\n");
		}
		imaqError = IMAQdxConfigureGrab(session);
		if(imaqError != IMAQdxErrorSuccess) {
			DriverStation::ReportError("IMAQdxConfigureGrab error: " + std::to_string((long)imaqError) + "\n");
		}
		IMAQdxStartAcquisition(session);
		oldCameraSel = CameraSel;
		time = time - Timer::GetFPGATimestamp();
		SmartDashboard::PutNumber("Switch:",time);
	}
//	if (CameraSel)
//		IMAQdxGrab(session2, frame, true, NULL);
//	else
		IMAQdxGrab(session, frame, true, NULL);
	if(imaqError != IMAQdxErrorSuccess) {
		DriverStation::ReportError("IMAQdxGrab error: " + std::to_string((long)imaqError) + "\n");
	} else {
		CameraServer::GetInstance()->SetImage(frame);
	}

}

void Robot::TestPeriodic() {
	lw->Run();
}

START_ROBOT_CLASS(Robot);

